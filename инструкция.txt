Ниже — понятное объяснение всей логики по слоям, с привязкой к файлам.

1) Конфиг групп и сопоставление staff_id
- Исходник групп — `config/groups.json`. Это результат парсинга `группировка.xlsx`: там только названия ресурсов и `company_id`.
- В рантайме ETL вызывает `resolve_staff_ids()` в `backend/app/groups.py`:
  - Берёт список филиалов из YCLIENTS (`/api/v1/companies`) и подставляет `display_name`, если он пустой или равен ID.
  - Для каждого филиала запрашивает сотрудников (`/api/v1/company/{company_id}/staff/0`).
  - Мапит `staff_id` по точному совпадению имени из `staff_names`.
  - Если совпадений нет или их несколько — пишет warning.
- Результат сохраняется в `config/groups_resolved.json`. При последующих запусках берётся он (если существует).

Файлы: `config/groups.json`, `config/groups_resolved.json`, `backend/app/groups.py`

2) Токены и настройки
- Конфиг читается в `backend/app/config.py`.
- `api token.txt` используется как `YCLIENTS_PARTNER_TOKEN`, если переменная не задана.
- При необходимости добавляется `YCLIENTS_USER_TOKEN` (если API требует).
- Там же задаются админ‑логины/пароли, таймзона, путь к БД и к конфигу.

Файл: `backend/app/config.py`

3) База данных и таблицы
- Инициализация в `backend/app/db.py`.
- Таблицы:
  - `raw_records` — сырые записи из YCLIENTS (фильтруем только факт посещения).
  - `staff_hour_busy` — факт занятости по часам для каждого staff.
  - `group_hour_load` — агрегаты по группам (busy_count, load_pct, in_benchmark).
  - `etl_runs` — статус/прогресс ETL.

Файл: `backend/app/db.py`

4) Бизнес‑правила и расчёт занятости
В `backend/app/etl.py`:
- Факт визита: учитываются `attendance` ∈ {1, 2}. Если `attendance` отсутствует, берём `visit_attendance`.
- Часовая занятость: если запись пересекает час — час считается занятым целиком.
- Benchmark‑окно: 10:00–21:59 (часы 10–21).
- Серая зона: <10 и ≥22 не влияет на проценты, но флаг есть для индикаторов.

5) ETL: full_2025
- `run_full_2025()`:
  1) Загружает/резолвит группы (staff_id + display_name филиалов).
  2) По каждому филиалу берёт записи за 2025 (`/api/v1/records/{company_id}`).
  3) Фильтрует по attendance и формирует `raw_records`.
  4) Строит `staff_hour_busy`.
  5) Строит `group_hour_load`.
- Прогресс и статус пишет в `etl_runs`.

Файл: `backend/app/etl.py`

6) ETL: daily (06:00)
- `run_daily()`:
  - Работает только за вчера (по `Europe/Moscow`).
  - Пересчитывает `staff_hour_busy` и `group_hour_load` только за этот день.
- Планировщик на APScheduler с cron 06:00.

Файлы: `backend/app/etl.py`, `backend/app/scheduler.py`

7) REST API для фронта
Реализовано в `backend/app/main.py`:
- `GET /api/branches` — филиалы.
- `GET /api/branches/{branch_id}/groups` — группы филиала.
- `GET /api/months/YYYY-MM/weeks` — список недель.
- `GET /api/heatmap` — 7×12 матрица (10–21), + серые индикаторы.
- `GET /api/summary/month` — средние (день/неделя/месяц).
- Admin:
  - `POST /api/admin/etl/full_2025/start`
  - `GET /api/admin/etl/status`

Файл: `backend/app/main.py`

8) Авторизация
- Cookie‑сессия (12 часов) через middleware.
- Пользователи `admin` и `admin2` берутся из env.

Файлы: `backend/app/main.py`, `backend/app/auth.py`

9) Фронтенд
- Шаблоны на Jinja, чистый JS.
- Дашборд:
  - Фильтры (месяц/филиал/группа/неделя).
  - Теплокарта 7×12.
  - Серые индикаторы (до 10 и после 22).
  - Средние метрики.
- Админка:
  - Кнопка запуска полного ETL.
  - Статус/прогресс/лог ошибок.

Файлы:
`backend/app/templates/dashboard.html`
`backend/app/templates/admin.html`
`backend/app/static/app.js`
`backend/app/static/admin.js`
`backend/app/static/styles.css`

10) Как проходит полный цикл
1) Вход в админку.
2) Запуск full ETL.
3) ETL формирует `groups_resolved.json` и заполняет БД.
4) Дашборд читает API и рисует теплокарту.
